# 面向对象编程

**Object-Oriented Programming**(OOP)

面向对象编程的本质就是**以类的方式组织代码，以对象的形式组织（封装）数据。**

- 抽象
- 三大特征：
  - **封装 **
  - **基础 **
  - **多态**


## 类与对象

**类是一种抽象的数据类型，是对某一类事物整体描述/定义，但是并不能代表某一个具体的食物**

- 动物、植物、手机、电脑
- Person类、Pet类、Car类等
- 这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为

**对象是抽象概念的具体实例**

- **某某某**是 **人** 的一个具体实例，**某某某家的旺财**就是 **狗** 的一个具体实例

- 能体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念

### 构造器

也称构造方法，实在进行创建对象的时候必须要调用的

- 必须和类的名字相同
- 必须没有返回类型，也不能写void

```java
package com.oop.demo02;

//构造器
public class Person {

    //一个类即使什么都不做，它也会存在一个方法
    //显式的定义构造器
    String name;

    //实例化 初始值
    //无参构造器，如果没有 有参构造器，无参构造器会默认生成，如果存在有参构造器，必须手动定义一个 无参构造器
    //1.使用new关键字，本质实在调用构造器
    //2.用来初始化值
    public Person(){}

    //有参构造：一旦定义了有参构造，无参构造就必须显式定义
    public Person(String name){

        this.name = name;
    }


}
/*
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person("Ember");
        System.out.println(person.name); //Ember
    }

    构造器：
        1.和类名相同
        2.没有返回值
    作用：
        1.new 本质在调用构造方法
        2.初始化对象的值
    注意点
        1.定义了有参构造之后，如果想使用无参构造，必须显式的定义一个无参构造

    alt + insert

    this.{}  = {};
 */
```



## 封装

程序设计应该追求 **高内聚，低耦合**

- 高内聚：类的内部数据操作细节由自己完成，不允许外部干涉
- 低耦合：仅暴露少量的方法给外部使用

**属性私有，get/set**

1. 提高程序的安全性，保护数据
2. 隐藏代码的实现细节
3. 统一接口
4. 系统的可维护性

```java
package com.oop.demo04;

//类  private：私有
public class Student {

    //属性私有
    private String name; //名字
    private int id; //学号
    private char sex; //性别
    private int age; //年龄

    //提供一些可以操作这个属性的方法
    //提供一些public 的 get || set 方法

    //get 获得这个数据
    public String getName(){
        return this.name;
    }

    //set 给这个数据设置值
    public void setName(String name){
        this.name = name;
    }

    //alt + insert
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public char getSex() {
        return sex;
    }
    public void setSex(char sex) {
        this.sex = sex;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        if (age>120 || age< 0){ //不合法
            this.age = 3;
        }else {
            this.age = age;
        }
    }

}
/*
public class Application {
    public static void main(String[] args) {
        Student s1 = new Student();

        s1.setName("闲鱼");

        System.out.println(s1.getName());

        s1.setAge(-1); //不合法
        System.out.println(s1.getAge());
    }
}
 */
```



## 继承

- 本质是对某一批类的抽象

- extends 就是 拓展，子类是父类的拓展

- JAVA中只有单继承，没有多继承，一个儿子只能有一个爹，但是一个爹可以有多个儿子

---

- 继承是 类 和 类之间的一种关系
- 继承关系的两个类，一个为子类（派生类），一个为父类（基类）。
  - 子类继承父类，使用关键词 `extends` 来表达
- 子类和父类之间，从意义上将应该具有 `is` `a` 的关系

---

- Object类
- super - this

```java
    1.super 调用父类的构造方法，必须在构造方法的第一个
    2.super 必须只能出现在子类的方法或者构造方法中
    3.super 和 this 不能同时调用构造方法
        
VS this:
	代表的对象不同：
        this：本身调用者这个对象
        super：代表父类对象的引用
    前提
        this：没有继承也可以使用
        super：只能在继承条件下才能使用
    构造方法
        this(); 本类的构造
        super(); 父类的构造
```

- 方法重写

```java
重写：需要有继承关系，子类重写父类的方法！
    1. 方法名必须相同
    2. 参数列表必须相同
    3. 修饰符：范围可以扩大：  public > protected > default > private 
    4. 抛出的异常：范围可以被缩小，但不能扩大  ClassNotFoundExcetion --> Excetion(大)
    
重写，子类的方法和父类的方法必须要一致，方法体不同
    
为什么需要出血：
    1. 父类的功能，子类不一定需要，或者不一定满足
    Alt + Insert  :  Override;
```



---
- A类

```java
package com.oop.demo05;
//继承关系，A 是 B 的子类
public class A extends B{
    //Override 重写
    @Override //注解：有功能的注释
    public void test() {
        System.out.println("A=>test()");
    }
}
```


- B类

```java
package com.oop.demo05;
//重写都是方法的重写，和属性无关
public class B {
    public void test(){
        System.out.println("B=>test()");
    }
}
```



- 调试 

```java
	//方法的调用只和左边的类型有关
	A a = new A();
	a.test(); //A
	//父类的引用指向了子类
	B b = new A(); //子类重写了父类的方法
	b.test(); //A
```



因为静态方法调用的是 **类** 自身的方法，而非静态方法调用的是 **对象** 的方法
有 **static** 时，**对象b** 调用了 **B类** 的方法，因为 **对象b** 是用 **B类** 定义的
没有 **static** 时，**对象b** 调用的是 **对象b自身(new A()）** 的方法，而 **b** 是用 **A类** *new* 的
即 **b** 是 **A** *new* 出来的**对象**，因此调用了 **A类** 的方法
因为 **A** 继承了 **B** ，并且 **A** 和 **B** 的方法名、参数都相同，用 **B类（父类）** *new* **A类（子类）** ，**B类（父类）** 的方法会被 **A类（子类）** 重写，也就是说如果父子类方法不带`static`父类的方法能被子类代替，前提是用 父类 new 了子类
